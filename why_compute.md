Type theories must be computational
===================================

Over 50 years of developments in intuitionistic type theory can be seen as a long journey to obtain
**A natural proof calculus for classical logic capable of structural induction over its own language.**

# Lavwere algebraic theories

School algebra is about transforming expressions. We learn basic operations such as addition and multiplication and basic identities they satisfy such as associativity, commutativity and distributivity. We compose basic operations to form expressions (= derived operations), and learn how to transform them by composing identities. 

High school algebra only deals with operations on some kind of numbers, in propositional logic we deal with operations (conjunction, disjunction, negation) on propositions. Actually, one can study operations abstractly, i.e. without specifying what they are intended to act on. That's precisely what universal algebra does: it studies finitely-generated sets of operations satisfying finitely-generated sets of identities.

Classical universal algebra usually deals with the case when operations are generated by constants, unary, and binary operations, operands being of the same sort as values. It is possible to generalize to the case with multiple sorts, e.g. vectors and scalars.

To generalize from propositional logic to predicate logic, we need an infinite number of sorts, namely the sort 0 of propositions, the sort 1 of propositions with one variable (unary predicates) and so forth for propositions with any finite number of variables (`n`-ary predicates). Quantifiers `∀` and `∃` bind one variable and thus decrement the sort of their operand. To state it precisely, quantifiers are not just two operations but an infinite families of operations: for any natural numbers `n < m` there is a specific variant of that accept m-ary predicates binding their `n`th hole. Binary operations like the conjunction and disjunction also turn into an infinite family. For unary predicates `R(x)` and `Q(x)` each binary operation * has two variants: it can either join the variables of predicates `R(x) * Q(x)` or leave them distinct `R(x) and Q(y)`. In the general case of an n-ary and and m-ary predicate, there will be many ways to join variables, but it is not hard to derive them all algorithmically. Thus, the set of operations is not finitely-generated anymore, but effectively generated (can be generated by an algorithm). The same applies to the set of identities, since we finite number of identities cannot govern an infinite number of primitive operations.

The gadget to deal with predicate logic algebraically is known as effectively generated Lawvere algebraic theory: it has a subcountable set of sorts, and effectively generated sets of operations and identities. As opposed to the case of finitely-generated theories, presenations of effectively generated ones include algorithms producing operations and identities, which have to be checked for termination and producing expressions of matching sorts, which requires some heavy computational machinery and is almost impossible to do by hand for nontrivial theories.

# Algebraic theories with dependent sorts

We already discussed operations acting on numbers, propositions, and predicates. Let us now consider operations acting on even more complex entities: proofs and programs.

A proof calculus is a two-level system much like vector spaces having the sort of vectors and the sort of scalars. The first layer is the layer of propositions and predicates we have already described as a Lawvere theory. In addition there will be the layer of proofs. Similar to propositions, we'll have sorts of proofs with `n` variables for each `n`. But it is more complicated than that. The sort of proof has to include the proposition or predicate being proven! Otherwise we cannot state the most basic operator on proofs `p ▸ q` that composes a proof of `A` and a proof of `A implies B` into a proof of  `B`. Sorts of proofs with `n` variables have to be of the form `Prf(p)`, where `p`is an `n`-ary predicate. We need to have dependent sorts: a feat Lawvere theories cannot accomodate.

In Lawvere algebraic theories, sorts are mere labels governing which expressions can be plugged together. An expression can be plugged into a hole of another expression if the sorts of the expression and the hole are identical. Sorts are syntactical entities, so it's OK to talk about them being identical, after all syntactical entities can be faithfully numbered and “identical” simply means “the same number”.

When generalising to allow value-dependent sorts `S(x)` we run into a problem. Values are semantic entities, so they can be equal without being represented by identical expressions. How can we even talk about sorts being identical or not if they depend on values?

Fortunately, values `x` occurring as sort arguments `S(x)` rules are not just any values, but values given by expressions of the very same theory, so it might be possible to provide an algorithm that computes canonical forms `|x|` so that equal values are mapped to identical normal forms. The operation `|_|` is where the computational aspect really comes into play.

For many sorts of interest it is is not possible to algorithmically extract canonical forms from values. For instance this is impossible for `n`-ary predicates with `n > 0`: word problem for their sorts is semiundecidable in the theory of predicate logic. If two predicates are indeed equal, systematic application of all possible identities will eventually find a path from one to another, but if they are distinct, this process will simply proceed indefinitely; we cannot in general prove distinctness of two predicates due to halting problem, which precludes existence of canonical forms. In such cases we can assign non-canonical normal forms `|_|` to values and find or introduce a (doubly dependent) sort `Id(a, b)` inhabited by identification paths from `a` to `b`. In our case we luckily already have one: two predicates can be shown equivalent precisely if we have a proof of the sort `Prf((A implies B) and (B implies A))`. This sort has to have property that it allows to plug expressions of the sort `Prf(A)` into holes of the sort `Prf(B)` if we have `p : Id(x, y)`, that is `p : Prf((A implies B) and (B implies A))`. In simple cases can have an algorithm that syntactically transforms expressions of the sort `Prf(A)` into expressions of the sort `Prf(B)`. This is unfortunatelly not alwasy possible. What turns out to be possible is an algorithm that syntactically transform the recipient expression with hole of the sort `Prf(A)` into an equivalent expression with the corresponding hole of the sort `Prf(B)` owing to additional flexibility that this syntactic transform can also change the resulting sort of the expression into an equivalent but non-identical one. Lifting expressions along identification paths gets really tricky when we work with systems where sorts can depend on values themselves being of a dependent sort. Luckily there is a whole well-developed area of mathematics dealing with lifting equivalences over equivalences — the abstract homotopy theory. I will argue that effective algebraic theories with dependent sorts are presented by weak model categories the same way as Lawvere algebraic theories are presented by finite-product categories.

Currently, we do not specify types of the variables bound by quantifiers: we can insist that some predicate holds only for natural numbers but not for, say, reals by using other predicates:
`(∀(n) isNat(n) implies P(n) )`. If we want our proof calculus to support proofs by induction, we have to use typed quantifiers instead. Induction is a proof operator that turns a proof of `P(0)` and a proof of `P(n) implies P(n + 1)` into a proof `(Nat∀(n) isNat(n) implies P(n))`. For advanced proof calculi we'll have to introduce lots of variable types and type-specific proof operators. At some we might want to make the type system extendable by introducing a sort `Type` of variable types and introducing expressions to compose advanced types from basic ones. Sorts `Pₙ` of n-ary predicates will become n-fold dependent on the sort of variable types: `P₀, P₁(T : Type), P₂(X Y : Type),...`. There is no way going back, so eventually we'll have to internalize the notion of dependent types and thus also replicate the normalization machinery machinery by splitting sorts `Expr(T)` and `Form(T)`, including `Expr(Type)` and `Form(Type)` themselves, and applying the approach known as bi-directional typing. Eventually we'll also discover how to compute path types for types themselves (namely as doubly dependent type with left and right inverse functions) discovering computational univalence.

Now let us switch from the prose to describing the computational machinery required to present algebraic theories with dependent sorts embracing their intimidating complexity.

# Introducing prototypes

For `n : ℕ` let us use the notation `↓n` for the type of size n usually known as `Fin n`. Given a vector of
types `Ts : ↓n -> U` we can define a tuple of values of the respective types as `vals : ∀(i : ↓n) Ts(i)`.

Below we'll introduce the notion of prototypes and introduce a prototype Δ⁺ so that a telescope of types
can be defined as `Ts : ↓n -> U` for `n : Δ⁺` and type of respective contexts as `∀(i : ↓n) Ts(i)`.
Moreover, it will be possible to introduce the prototype Δ that additionally keeps track of context
extensions `ext : Ts ⊂ Ts'` and allows extending functions on `(ctx : ∀(i : ↓n) Ts(i))` to functions on
`(ctx : ∀(i : ↓n) Ts'(i))` along `ext` automatically.

Prototypes are type-theoretical counterparts of Reedy categories.

A prototype `T` is an inductive type `|T| : *` defined mutually with two following inductive-recursive types:
```
Reductions[T] : *, .to : T,   .precompose  : (x : Reductions[.to])  ->  Reductions[T] with .to ≡ x.to
Extensions[T] : *, .from : T, .postcompose : (x : Extensions[.from]) -> Extensions[T] with .from ≡ x.from
```
The definitional equalities must be checked. It is only possible if `t.to` and `t.from` are structurally smaller
then `t`. It ensures that the arguments `x` of the functions precompose and postcompose come from a type that
has already been defined, its constructors are known and values of .to and .from on resulting values can be
explicitly computed. Since compositions of reductions and extensions are represented by composition of functions,
it is definitionally associative. The involution T° on prototypes simply exchanges reductions and extensions.
The prefix operator (↓ ) generates a derived downward prototype for each element `t : |T|` consisting only of
those elements of `|T|` that t can be reduced to, and their respective reductions. The universe of derived
downward prototypes comes for a fixed prototype `T` comes with a prototype structure induced by reductions
and extensions in `T` acting elementwise.

The type of functions `X -> Y` from a prototype is undefined unless `Y` is a universe (thus a category),
in which case `X -> Y` is a universe as well. Now assume `F[t : T]` is a type dependent on prototype `T`.
Values of type `x : F[t : T]` come with actions of reductions `rx : F[r.to]`, where `r : Reductions[t]`.

Functions `f` on `F[t : T]` have to provide action on “higher constructors” `e : Extensons[x]` yielding
either a path `f(x) = f(e.from)` or an extension `Extension[f(x)]` with .from ≡ f(e.from).

Type-valued functions `F[t : T]` on prototypes are defined using the following form of elimination:
Constructors `c : |T|` should map to types dependent on `((r : Reductions[c]) -> F[r.to])`. Higher
constructors `e : Extensons[t]` should evaluate to maps `F[e.from] -> F[e]`.


