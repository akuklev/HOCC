Type theories must be computational
===================================

# Lavwere algebraic theories

School algebra is about transforming expressions. We learn basic operations such as addition and multiplication and basic identities they satisfy such as associativity, commutativity and distributivity. We compose basic operations to form expressions (= derived operations), and learn how to transform them by composing laws. 

High school algebra only deals with operations on some kind of numbers, in propositional logic we deal with operations (conjunction, disjunction, negation) on propositions. Actually, one can study operations abstractly, i.e. without specifying what they are intended to act on. That's precisely what universal algebra does: it studies finitely-generated sets of operations satisfying finitely-generated sets of identities.

Classical universal algebra usually deals with the case when operations are generated by constants, unary, and binary operations, operands being of the same sort as values. It is possible to generalize to the case with multiple sorts, e.g. vectors and scalars.

To generalize from propositional logic to predicate logic, we need an infinite number of sorts, namely the sort 0 of propositions, the sort 1 of propositions with one variable (unary predicates) and so forth for propositions with any finite number of variables (`n`-ary predicates). Quantifiers `∀` and `∃` bind one variable and thus decrement the sort of their operand. To state it precisely, quantifiers are not just two operations but an infinite families of operations: for any natural numbers `n < m` there is a specific variant of that accept m-ary predicates binding their `n`th hole. Binary operations like the conjunction and disjunction also turn into an infinite family. For unary predicates `R(x)` and `Q(x)` each binary operation * has two variants: it can either join the variables of predicates `R(x) * Q(x)` or leave them distinct `R(x) and Q(y)`. In the general case of an n-ary and and m-ary predicate, there will be many ways to join variables, but it is not hard to derive them all algorithmically. Thus, the set of operations is not finitely-generated anymore, but effectively generated (can be generated by an algorithm). The same applies to the set of identities, since we finite number of identities cannot govern an infinite number of primitive operations.

The gadget to deal with predicate logic algebraically is known as effectively generated Lawvere algebraic theory: it has a subcountable set of sorts, and effectively generated sets of operations and identities.

# Algebraic theories with dependent sorts

We already discussed operations acting on numbers, propositions, and predicates. Let us now consider operations acting on even more complex entities: proofs and programs.

A proof calculus is a two-level system much like vector spaces having the sort of vectors and the sort of scalars. The first layer is the layer of propositions and predicates we have already described as a Lawvere theory. In addition there will be the layer of proofs. Similar to propositions, we'll have sorts of proofs with `n` variables for each `n`. But it is more complicated than that. The sort of proof has to include the proposition or predicate being proven! Otherwise we cannot state the most basic operator on proofs `p ▸ q` that composes a proof of `A` and a proof of `A implies B` into a proof of  `B`. Sorts of proofs with `n` variables have to be of the form `Prf(p)`, where `p`is an `n`-ary predicate. We need to have dependent sorts: a feat Lawvere theories cannot accomodate.

In Lawvere algebraic theories, sorts are mere labels governing which expressions can be plugged together. An expression can be plugged into a hole of another expression if the sorts of the expression and the hole are identical. Sorts are syntactical entities, so it's OK to talk about them being identical, after all syntactical entities can be faithfully numbered and “identical” simply means “the same number”.

When generalising to allow value-dependent sorts `S(x)` we run into a problem. Values are semantic entities, so they can be equal without being represented by identical expressions. How can we even talk about sorts being identical or not if they depend on values?

Well, we can if we have an operation `|_|` mapping values `x` (semantical entities) to their canonical forms `|x|` (syntactic entities). So technically, sorts depend on canonical forms, rather than values themselves. This way we can again speak of identical sorts and know when it is possible to plug expressions together. The operation `|_|` is where the computational aspekt comes into play, which didn't occur in case of algebraic theories without dependent sorts.

In many (actually, most) cases of interest it is not possible to algorithmically extract canonical forms from values. In fact, values might even come from an uncountable set, so that is impossible to have enough canonical forms. Fortunately, values `x` occurring as sort arguments `S(|x|)` in rules of algebraic theories are not just any values, but values given by expressions of the very same theory, and for them we often can have enough forms, but those won't be canonical anymore: equal values `x` and `y` might end up having non-identical normal forms `|x|` and `|y|`. (Not necesarlly canonical forms are called normal forms or simply forms.) However, we want to be able to somehow plug expressions of the sort `S(|x|)` into holes of the sort `S(|y|)`. While very tempting, it turns out to be in general impossible to algorithmically convert expressions of the sort `S(|x|)` into expression of the sort `S(|y|)` even if we know that `x = y`, but it is possible to turn an expression with a hole of the sort `S(|x|)`-value into an equivalent expression with the same hole having the sort `S(|y|)` given an equality proof.

Тут про то, что мы можем иметь внутри теории типы — термы особого сорта *, представляющие сорта, то есть в качестве сортов мы можем использовать их нормальные формы e : |t|. Дальше сказать что у типов вместо равенства эквивалентность ххх, и она бывает разная, но мы можем поднимать выражения сдыркой вдоль identification path, как поднимали в случае значений используя доказательство равенства. И эта операция называется identification path lifting, и область математики которая описывает path lifting properties называется абстрактной теорией гомотопий — вот где эта штука вступает.
