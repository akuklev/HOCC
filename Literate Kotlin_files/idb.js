var circlet;window.storageResolvers&&function(e,r=1,t="arenas"){const o=function(e,r,t){const o=new Promise(((o,n)=>{const s=indexedDB.open(e,r);s.onupgradeneeded=e=>{const r=e.target.result;r.objectStoreNames.contains(t)||r.createObjectStore(t)},s.onsuccess=e=>o(e.target.result),s.onerror=e=>n(e.target.error)})),n=(e,r)=>o.then((o=>{const n=o.transaction([t],e),s=n.objectStore(t);return r(s,n)})),s=(e,r)=>{if(e)return r?e:IDBKeyRange.bound(e,e+"ï¿¿",!1,!1)};return{get:(e,r=!0)=>n("readonly",(t=>{const o={},n=t.openCursor(s(e,r));return new Promise(((e,r)=>{n.onsuccess=r=>{const t=r.target.result;if(!t)return e(o);o[t.key]=t.value,t.continue()},n.onerror=e=>r(e.target.error)}))})),put:e=>n("readwrite",((r,t)=>new Promise(((o,n)=>{Object.entries(e).forEach((([e,t])=>{r.put(t,e)})),t.oncommit=()=>o(),t.onerror=e=>n(e.result.error)})))),del:(e,r=!0)=>n("readwrite",(t=>{const o=e?t.delete(s(e,r)):t.clear();return new Promise(((e,r)=>{o.onsuccess=r=>e(),o.onerror=e=>r(e.target.error)}))})),count:()=>n("readonly",(e=>{const r=e.count();return new Promise(((e,t)=>{r.onsuccess=t=>e(r.result),r.onerror=e=>t(e.target.error)}))}))}}("arenas",r,t);let n=new Map;const s=e=>n.get(e),c=(e,r)=>(n.set(e,r),o.put({[e]:r}).catch(console.error)),a=(e,r=!0)=>{if(e&&r)n.delete(e);else if(e)for(const r of n.keys())r.startsWith(e)&&n.delete(r);else n.clear();return o.del(e,r).catch(console.error)},i=e=>{const r=Array.from(n.keys());return e?r.filter((r=>r.startsWith(e))):r};return o.count().then((e=>(console.log("idb: number of records %o",e),e>0?o.get():{}))).then((e=>(n=new Map(Object.entries(e)),{put:c,get:s,keys:i,del:a})))}().then((e=>{window.storageResolvers.resolve(e),window.storage=e})).catch((e=>{window.storageResolvers.reject(e)})),(circlet=void 0===circlet?{}:circlet).idb={};